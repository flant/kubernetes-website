---
reviewers:
title: Лучшие практики в области конфигурирования
content_type: concept
weight: 10
---

<!-- overview -->
В этом документе освещаются и обобщаются рекомендации по настройке, которые представлены в руководстве пользователя, документации по началу работы и примерах.

Документ постоянно обновляется. Если в нем отсутствует что-то, что может быть полезным для других, смело открывайте Issue или готовьте соответствующий PR.


<!-- body -->
## Общие советы по конфигурированию

- При составлении конфигураций указывайте последнюю стабильную версию API.

- Конфигурационные файлы должны храниться в системе контроля версий и передаваться в кластер из нее. Это позволяет при необходимости быстро откатить изменения в конфигурации и помогает при пересоздании и восстановлении кластера.

- Для файлов конфигураций используйте YAML, а не JSON. Хотя в большинстве случаев эти форматы взаимозаменяемы, YAML, как правило, более дружественен к пользователю.

- Группируйте связанные объекты в один файл, если это имеет смысл. Одним файлом проще управлять, чем несколькими. Пример такого подхода/синтаксиса можно найти в файле [guestbook-all-in-one.yaml](https://github.com/kubernetes/examples/tree/master/guestbook/all-in-one/guestbook-all-in-one.yaml).

- Обратите внимание, что многие команды `kubectl` способны работать с директориями. Например, если указать директорию в качестве параметра `kubectl apply`, команда применит все конфигурационные файлы из этой директории.

- Не указывайте значения по умолчанию без необходимости: простая, минималистичная конфигурация снижает вероятность ошибок.

- Включайте описания объектов в аннотации, чтобы упростить интроспекцию.


## "Голые" Pod'ы и ReplicaSet'ы, Deployment'ы и Job'ы {#naked-pods-vs-replicasets-deployments-and-jobs}

- По возможности не используйте "голые" ("naked") Pod'ы (т.е. Pod'ы, которые не управляются [ReplicaSet'ом](/docs/concepts/workloads/controllers/replicaset/) или [Deployment'ом](/docs/concepts/workloads/controllers/deployment/)). Такие Pod'ы не будут перепланироваться в случае сбоя узла.

  Объединение Pod'ов в рамках Deployment'а, который создает ReplicaSet (данный объект отвечает за постоянное наличие необходимого количества Pod'ов) и определяет стратегию замены Pod'ов (например, [RollingUpdate](/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment)), почти всегда предпочтительнее, чем создание Pod'ов напрямую (за исключением некоторых сценариев с [`restartPolicy: Never`](/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy). Объект типа [Job](/docs/concepts/workloads/controllers/job/) также подходит для управления Pod'ами.

## Сервисы

- Создавайте [Сервис](/docs/concepts/services-networking/service/) до соответствующих бэкендов (Deployment'ов и ReplicaSet'ов) и иных рабочих нагрузок, которым может потребоваться доступ к нему. Kubernetes задает переменные окружения, указывающие на все Сервисы, которые работали на момент создания контейнера. Предположим, что в кластере работает Сервис `foo`. В этом случае во всех запускаемых контейнерах будут определены следующие переменные окружения:

  ```shell
  FOO_SERVICE_HOST=<хост, на котором запущен Сервис>
  FOO_SERVICE_PORT=<порт, на котором доступен Сервис>
  ```

  *Порядок в данном случае важен:* любой Сервис, необходимый Pod'у, должен создаваться до самого Pod'а, иначе соответствующие переменные окружения в последнем не будут установлены. На DNS это ограничение не распространяется.

- DNS-сервер – необязательно (хотя и настоятельно рекомендуемое) [дополнение к кластеру](/docs/concepts/cluster-administration/addons/).  Сервер DNS с помощью API Kubernetes следит за появлением новых Сервисов и создает набор DNS-записей для каждого из них. Если DNS включен во всем кластере, все Pod'ы смогут выполнять разрешение имен Сервисов автоматически.

- Задавайте `hostPort` для Pod'а только если это абсолютно необходимо. Привязывая Pod к `hostPort'у`, вы сильно ограничиваете возможности планировщика, поскольку каждая комбинация <`hostIP`, `hostPort`, `protocol`> должна быть уникальной. Если не указать `hostIP` и `protocol` явно, Kubernetes будет использовать `0.0.0.0` в качестве `hostIP` по умолчанию и `TCP` в качестве протокола по умолчанию.

  Если доступ к порту нужен только для отладки, можно использовать [прокси сервера API](/docs/tasks/access-application-cluster/access-cluster/#manually-constructing-apiserver-proxy-urls) или [`kubectl port-forward`](/docs/tasks/access-application-cluster/port-forward-access-application-cluster/).

  Если необходимо явно открыть порт Pod'а на узле, рассмотрите возможность использования сервиса [NodePort](/docs/concepts/services-networking/service/#type-nodeport) прежде чем прибегать к `hostPort`.

- Избегайте использования `hostNetwork` по тем же причинам, что и `hostPort`.

- Используйте [headless-Сервисы](/docs/concepts/services-networking/service/#headless-services) (с `ClusterIP` `None`) для обнаружения сервисов, если балансировка нагрузки `kube-proxy` не требуется.

## Использование лейблов

- Создавайте и используйте [лейблы](/docs/concepts/overview/working-with-objects/labels/) которые описывают __семантические атрибуты__ приложения или развертывания, например `{ app.kubernetes.io/name: MyApp, tier: frontend, phase: test, deployment: v3 }`. Эти лейблы можно использовать для выбора соответствующих Pod'ов для других ресурсов; например, Сервис может выбирать все Pod'ы с лейблом `tier: frontend` или все компоненты с лейблом `phase: test` приложения `app.kubernetes.io/name: MyApp`. См. примеры такого подхода в приложении [Гостевая книга](https://github.com/kubernetes/examples/tree/master/guestbook/).

Сервис может охватывать сразу несколько развертываний; для этого следует опустить в его селекторе лейблы, относящиеся к конкретному релизу. Чтобы обновить работающий сервис без простоя, используйте [Deployment](/docs/concepts/workloads/controllers/deployment/).

Желаемое состояние объекта описывается в спецификации Deployment'а. Если в эту спецификацию внести изменения (_apply_), контроллер развертывания постепенно и контролируемым образом приведет фактическое состояние к желаемому.

- Используйте [общепринятые лейблы Kubernetes](/docs/concepts/overview/working-with-objects/common-labels/) для типовых ситуаций. Такие стандартизированные метки обогащают метаданные и упрощают взаимодействие инструментов, включая `kubectl` и [панель управления](/docs/tasks/access-application-cluster/web-ui-dashboard).

- С помощью лейблов можно управлять отладкой. Поскольку контроллеры Kubernetes (например, ReplicaSet) и Сервисы выбирают Pod'ы с помощью лейблов selector, удаление соответствующих лейблов не позволит контроллеру использовать Pod, а Сервису – направлять на него трафик. Если удалить лейблы у существующего Pod'а, контроллер создаст новый Pod ему на замену. Это может пригодиться для отладки ранее "живого" Pod'а в условиях "карантина". Для интерактивного удаления или добавления меток воспользуйтесь командой [`kubectl label`](/docs/reference/generated/kubectl/kubectl-commands#label).

## Использование kubectl

- Команда `kubectl apply -f <директория>` ищет конфигурации Kubernetes во всех `.yaml`, `.yml`, and `.json` файлах в указанной `<директории>` и применяет (`apply`) их.

- Используйте селекторы лейблов для операций `get` и `delete` вместо конкретных имен объектов. См. разделы о [селекторах лейблов](/docs/concepts/overview/working-with-objects/labels/#label-selectors) и [эффективном использовании лейблов](/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively).

- Команды `kubectl create deployment` и `kubectl expose` позволяют быстро создавать одноконтейнерные развертывания и сервисы. Пример использования сервиса для доступа к приложению в кластере см. в разделе [Использование сервиса для доступа к приложению в кластере](/docs/tasks/access-application-cluster/service-access-application-cluster/).


